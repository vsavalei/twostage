---
title: "Complete data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Complete_data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

#devtools::build_rmd("vignettes/Complete_data.Rmd") 

#Run build and not build_rmd(): Use devtools::build_vignettes() to build the vignettes. This command #ensures all vignettes are compiled correctly and links are processed within the package context.
```

It is instructive to see how the item-level models and approaches can yield the same results as when the model is fit directly to the composites, when there is no missing data. 

We will use the built-in dataset `tpbdata`, which does not contain any missing values. This dataset was collected to test the theory of planned behavior, and contains 11 Attitudes items, 3 Perceived Behavioral Control (PBC) items, 3 Norms items, 3 Intention items, and 1 measure of Behavior; for more information, see `help(tpbdata)`. 

In the syntax below, we first create a new dataset that contains only the composites: 

```{r tpbdatac}
library(twostage)

tpbdatac<-data.frame(matrix(ncol = 0, nrow = nrow(tpbdata))) #new data frame
at_names <- grep("AT", names(tpbdata), value = TRUE) #names of 11 attitude items
tpbdatac$ATTALL<-rowSums(tpbdata[at_names]) #new variable that is sum of 11 attitude items
tpbdatac$PBCALL<-rowSums(tpbdata[c("PBC1","PBC2","PBC3")]) #new variable that is sum of 3 PBC items
tpbdatac$NORSALL<-rowSums(tpbdata[c("NORS1","NORS2","NORS3")]) #new variable that is sum of 3 NORS items
tpbdatac$INTALL<-rowSums(tpbdata[c("INT1","INT2","INT3")]) #new variable that is sum of 3 INT items
tpbdatac$BEH<-rowSums(tpbdata["BEH"]) #BEH variable copied from the original dataset
```

We then specify the composite-level model, which hypothesizes full mediation, and fit it in `lavaan`: 

```{r comp}
#composite-level model (BEH stays as as single indicator variable)
tpbmod<-'
INTALL ~ ATTALL + PBCALL + NORSALL
BEH ~ INTALL'

fit_comp<-lavaan::sem(tpbmod,data=tpbdatac,fixed.x=FALSE,meanstructure=TRUE)
fit_comp
est_comp<-lavaan::parameterestimates(fit_comp,ci=FALSE) #parameter estimates
est_comp

```
The printed chi-square, df, parameter estimates, and standard errors from `fit_comp` will be the values to match by the item-level methods. All these methods fit the model to the original dataset `tpbdata` containing only the items, without computing the composites explicitly. 

We first need to define the matrix $C$ that relates composites to components. The end user can assign components to composites interactively as follows:

``` 
C <- stage0(data=tpbdata,model=tpbmod)
```
For this vignette, we specify this matrix manually: 

```{r C}
cnames<-lavaan::lavNames(tpbmod)
C <- matrix(0,nrow=length(cnames),ncol=length(colnames(tpbdata)))
colnames(C)<-colnames(tpbdata)
rownames(C)<-cnames
C[1,c("INT1","INT2","INT3")]<-1
C[2,c("BEH")]<-1
C[3,grep("AT", names(tpbdata))]<-1
C[4,c("PBC1","PBC2","PBC3")]<-1
C[5,c("NORS1","NORS2","NORS3")]<-1
C
```

### TSML 

To match the complete data analysis when using TSML, we have to specify expected rather than observed information for Stage 1 (via `runcommand`), and `sample.cov.rescale=FALSE` for Stage 2, which skips the multiplication of the input covariance matrix by $(N-1)/N$ (via `runcommand2`).   

```{r TSML1}
fit_tsml <- twostage(data = tpbdata, model = tpbmod, C = C,
runcommand = "information='expected'", runcommand2 = "meanstructure=TRUE,
fixed.x=FALSE,sample.cov.rescale=FALSE")
```

The summary output shows the TS parameter estimates, the "naive" standard errors from Stage 2(`se`), and the TSML standard errors, adjusted for missing data uncertainty in Stage 1: 

```{r TSML2}
summary(fit_tsml) 
```

In this case, because the data are complete and we have matched the type of information used in Stage 1 to what is used by default with complete data, the "naive" and "TSML" standard errors are identical. In addition, both the estimates and the standard errors are identical to six decimal places (Note: I actually expected better...) to what was obtained in `fit_comp`, when the model was fit directly to the composites:

```{r comp_vs_TSML}
max(abs(est_comp$est-lavaan::parameterestimates(fit_tsml$TS_Run_naive)$est)) #comparing estimates
max(abs(est_comp$se-lavaan::parameterestimates(fit_tsml$TS_Run_naive)$se)) #comparing complete data analysis and naive SEs from TSML
max(abs(est_comp$se-fit_tsml$TS_SEs)) #comparing complete data analysis and TSML SEs 
```

The naive chi-square is identical to the chi-square from the direct composites analysis in `fit_comp`. (The entire naive Stage 2 output is stored in `fit_tsml$TS_Run_naive`.) The residual-based TSML chi-square produces a slightly different value from the naive chi-square; because it is computed as a quadratic form, and does not use the ML fit function equation, it will be highly similar, but not numerically identical to the "naive" ML chi-square even when the data are complete. (A much smaller source of difference is that it uses N-1 rather than N as sample size multiplier, but this could be changed.) Instead, it will be equal to the chi-square from the GLS method, which can be verified by running:
```
fit_comp_gls<-lavaan::sem(tpbmod,data=tpbdatac,fixed.x=FALSE,meanstructure=TRUE,estimator="GLS")
```
When the model is correct, both GLS and ML are asymptotically fully efficient, and they are also asymptotically equivalent. 

### PIM

The PIM model syntax sets up each composite as a special latent variable, with the structure on the observed variables such that the latent variable turns out to be equal to the observed composite (add more detail?). The composites model is then embedded within the larger PIM model. We obtain the `lavaan` syntax for PIM as follows: 
```{r PIM1}
tpbpim <- PIM_syntax(C=C,compmodel=tpbmod)
cat(tpbpim)
```

We then fit this model in `lavaan` (without declaring missing data):

```{r PIM2}
fit_pim <- lavaan::sem(tpbpim, data=tpbdata)
fit_pim
est_pim<-lavaan::parameterestimates(fit_pim,ci=FALSE) 
```
The test statistic value and df are identical to `fit_comp`, even though the number of model parameters is much higher (`r lavaan::fitmeasures(fit_pim)["npar"]`), because the items are also in the model (but in a saturated form).  

The parameter estimates and standard errors for the relevant parameters are identical to those from the `fit_comp` run: 

```{r PIM3}
#grab parameter names from the complete data run
est_comp_key <- paste(est_comp$lhs, est_comp$op, est_comp$rhs, sep = "")
#grab parameter names from the PIM run
est_pim$key <- paste(est_pim$lhs, est_pim$op, est_pim$rhs, sep = "") 
#show estimates and standard errors from the PIM run only for relevant parameters
est_pim[est_pim$key %in% est_comp_key, 1:5]

```

As a sidenote, we could have also matched the standard errors for all three approaches by using observed information, by specifying ```information='observed'``` for `fit_comp` and `fit_pim` runs, and omitting `runcommand="information='expected'"` for `fit_tsml`.  


### Approximate Fit Assessment 

With complete data, fit measures for the direct composites run and the naive Stage 2 fit measures for the TSML run are the same: 

```{r afi1}
afi_comp <- lavaan::fitmeasures(fit_comp)
afi_ts_naive <- lavaan::fitmeasures(fit_tsml$TS_Run_naive) 
round(cbind(afi_comp,afi_ts_naive),3)
```

On the other hand, some PIM fit metrics can be weird even with complete data: 
```{r afi2}
afi_pim <- lavaan::fitmeasures(fit_pim)
round(cbind(afi_comp,afi_ts_naive,afi_pim),3)
```
Specifically, while the chi-square test and the RMSEA are unaffected, a custom baseline model has to be specified to get the right CFI and other relative fit indices with PIM. The SRMR also needs to be computed differently. [We need functions for these]. The AIC/BIC values are not relevant as long as the same type of model is being compared (e.g., if different types of path models for composites are compared using the AIC, where all are implemented via PIM, that should be fine.)

To learn more about approximate fit assessment with different methods for composite model, see [Approximate_fit vignette](../doc/Approximate_fit.html).
