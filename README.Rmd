---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

<!-- Render `README.Rmd` regularly to keep `README.md` up-to-date, via
`devtools::build_readme()` -->


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# Package `twostage`

## Introduction

<!-- badges: start -->
[![R-CMD-check](https://github.com/vsavalei/twostage/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/vsavalei/twostage/actions/workflows/R-CMD-check.yaml)
<!-- badges: end -->


The goal of the `twostage` package is to provide helpful automation to fit composite-level 
structural equation models (SEMs) to item-level data using the SEM R package `lavaan`. The most common applications are: 1) SEMs with parcels and 2) path analysis with scale scores.  

The package includes automation for the following approaches: 

1) The two-stage ML (TSML) method of [Savalei and Rhemtulla (2017a)](https://journals.sagepub.com/doi/full/10.3102/1076998617694880) 
2) The Pseudo-Indicator Model (PIM) of [Rose, Wagner, Mayer, and Nagengast (2019)](https://online.ucpress.edu/collabra/article/5/1/9/112958/Model-Based-Manifest-and-Latent-Composite-Scores) 
3) (yet to be added) the GLS method of [Savalei and Rhemtulla (2017b)](https://www.frontiersin.org/journals/psychology/articles/10.3389/fpsyg.2017.00767/full)

The main purpose of these three approaches is to handle missing data at the item level. When data are complete, these methods/models will return identical (or highly similar, depending on information matrix settings) results compared to the approach where composites are computed directly, and a model is fit to them (see vignette TBA). The composites are always sums or averages of the items; the weights are all equal and are fixed rather than estimated.

In the future, the package may also include confirmatory composite analysis (CCA; Henseler, YEAR), which is similar to PIM in that it models composites as latent variables, but it 1) finds optimally weighted composites (for prediction), and 2) does not allow indicators to influence other variables directly (but only through the composite). This approach will *not* return identical results to composite models with complete data, and is thus qualitatively different. CCA is currently being implemented in the development version of `lavaan`, but not in a way that would allow missing data on the indicators of exogenous composites. Including it in `twostage` would enable a study of its performance with missing data. 


## Installation

You can install the development version of twostage from [GitHub](https://github.com/) with:

``` r
install.packages("pak")
pak::pak("vsavalei/twostage")
```
You can load it in the usual way:

``` {r}
library(twostage) 
```

<!-- too large? hard to illustrate PIM -->
## Example

This example uses a simulated dataset `misdata_mcar20`, 
which contains 27 items, $Y_1$ to $Y_{27}$, where about half have 20\% missing data. The model is for composites $C_1$ to $C_9$, which are parcels of three items each, in order; for example, $C_1 = Y_1 + Y_2 + Y_3$, and so on. These composites are never explicitly computed under any of the three methods. 

The composite model is a 3-factor model, with three indicators each, defined 
via `lavaan` syntax as follows: 

```{r}
#composite model
mod <- '
F1 =~ C1 + C2 + C3
F2 =~ C4 + C5 + C6
F3 =~ C7 + C8 + C9
'
```
To fit this composite model using the item-level methods in this package, the specification of a $27 \times 9$ matrix $C$ assigning components to composites is first required. The columns are labeled with component names: $Y_1$ to $Y_{27}$, and the rows are labeled with composite names: $C_1$ to $C_9$. The [i,j]th element of $C$ is nonzero (for sums, it is 1) if component $j$ belongs to composite $i$, and zero otherwise. To create this matrix using an interactive interface, use: 

```
C <- stage0(data=misdata_mcar20,model=mod)
```
This function will first ask the user whether the composites are sums or averages, and then it will ask the user to assign each component to one of the variable names (assumed to be composites) that appear in the model. The following message will confirm the assignment:

```
Your composites are made up of the following components: 
C1 :  Y1 Y2 Y3 
C2 :  Y4 Y5 Y6 
C3 :  Y7 Y8 Y9 
C4 :  Y10 Y11 Y12 
C5 :  Y13 Y14 Y15 
C6 :  Y16 Y17 Y18 
C7 :  Y19 Y20 Y21 
C8 :  Y22 Y23 Y24 
C9 :  Y25 Y26 Y27 
If this is not correct, start over! 
```


```{r, include = FALSE}
cnames<-lavaan::lavNames(mod) 
C <- matrix(0,nrow=length(cnames),ncol=length(colnames(misdata_mcar20)))
colnames(C)<-colnames(misdata_mcar20)

#lavaan is there with library(twostage) (user) and load_all() (dev)
rownames(C)<-cnames
C[1,1:3]<-1
C[2,4:6]<-1
C[3,7:9]<-1
C[4,10:12]<-1
C[5,13:15]<-1
C[6,16:18]<-1
C[7,19:21]<-1
C[8,22:24]<-1
C[9,25:27]<-1
```

Once the $C$ matrix is created with the help of the `stage0` function (or manually), the composite-level model can be fit using the methods included in the package. 

To fit the composite-level model using TSML:

```{r}
fit_ts <- twostage(data = misdata_mcar20, model = mod, C = C)
summary(fit_ts)
```
The output shows TSML parameter estimates from Stage 2, "naive" standard errors, and  TSML standard errors, which are generally larger, reflecting greater uncertainty due to missing data in Stage 1. The residual-based test statistic is also printed. This output assumes normality. For technical details on the standard errors and the residual-based test statistic computation, see [Savalei and Bentler ( 2009)](https://www.tandfonline.com/doi/full/10.1080/10705510903008238) and [Savalei and Rhemtulla (2017a)](https://journals.sagepub.com/doi/full/10.3102/1076998617694880). 

To fit the composite model using PIM, the package automates the creation of the  `lavaan` PIM syntax: 

```{r}
modpim <- PIM_syntax(compmodel = mod, C = C)

```

The resulting syntax is long and can be viewed via `cat(modpim)`. It contains 
the definition of each composite $C_i$, $i=1,\ldots,9$, as a single-indicator latent variable, and a special structure on the items. For details, see [Rose, Wagner, Mayer, and Nagengast (2019).](https://online.ucpress.edu/collabra/article/5/1/9/112958/Model-Based-Manifest-and-Latent-Composite-Scores) 

The PIM model can be fit directly in `lavaan`, using FIML to treat missing data on the items:

```{r}
fit_pim <- lavaan::sem(modpim, data=misdata_mcar20,missing="FIML")
fit_pim

ests <- lavaan::parameterestimates(fit_pim)
ests_comp <- ests[!grepl("Y", ests[, "lhs"]) & !grepl("Y", ests[, "rhs"]), ]
ests_comp
```

As the interest is in the composite model, the user just has to ignore a lot of extraneous output pertaining to the item parameters. In the output shown above, the output of the `parameterestimates` function is modified by removing all rows referring to a "Y" variable (i.e., an item). 

To compare estimates of common parameters in TS and PIM, the user can use built-in compare functions:

```{r}
comp_table <- compare_est(fit_pim,fit_ts)

#rounding numeric columns to three decimal places
as.data.frame(lapply(comp_table, function(x) {
  if(is.numeric(x)) { round(x, 3) } else {x} }))

```

The only complicating element for TS and PIM methods is approximate fit assessment; this aspect is under development, see Approximate_fit vignette. When data are complete, both TS and PIM produce equivalent output to the complete data run on the manually-formed composites, see the Complete_data vignette. 

<!-- Links to (../doc/Complete_data.html) do not work until the package website is on Github. Links to  (../vignettes/Complete_data.html) do not work because this folder does not contain hmtl files. Ignore for now, see advice below.

<!-- Note on GitHub: If the README is on GitHub and you want to link to the rendered vignette during development, you could manually provide a link to a rendered version stored externally (e.g., on GitHub Pages) until it is published on CRAN.-->
