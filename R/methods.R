# In this file:
# S4 methods: show, summary (creates an object of class SummaryTwoStage),
# #           fitMeasures (lavaan generic) for twostage objects
# S3 method: print for SummaryTwostage object
# function parameterEstimates_ts (as lavaan's parameterEstimates is not an S3 method)
# creating an object of class twostage_parameterEstimates
# S3 method: print for twostage_parameterEstimates


#' Display method for twostage objects
#' @param object A twostage object
#' @exportMethod show

setMethod("show", "twostage", function(object) {
  # Capture output while suppressing direct printing (appears necessary or else double)
  original_output <- capture.output({
    invisible(callNextMethod())
  })

  # Replace "ML" with "TS"
  modified_output <- gsub("\\bML\\b", "TS", original_output)

  # Find the lavaan version line and modify it
  lavaan_line_idx <- grep("^lavaan .* ended normally after .* iterations", modified_output)
  if (length(lavaan_line_idx) > 0) {
    # Extract version info from the line
    original_line <- modified_output[lavaan_line_idx]

    # Print Stage 1 info if available
    if (!is.null(object@twostage$stage1_info)) {
      s1_info <- object@twostage$stage1_info
      cat(
        "Stage 1: lavaan", object@version,
        ifelse(s1_info$converged, "ended normally", "did NOT converge"),
        "after", s1_info$iterations, "iterations\n"
      )
    }

    # Modify the lavaan line to say "Stage 2:"
    modified_output[lavaan_line_idx] <- gsub("^lavaan", "Stage 2: lavaan", original_line)
  }

  # Find and modify the test statistic line to maintain alignment (a bit off)
  stat_line_idx <- grep("Test statistic", modified_output)
  if (length(stat_line_idx) > 0 && !is.null(object@twostage$test)) {
    # Replace entire line to control spacing
    modified_output[stat_line_idx] <- sprintf(
      "  Residual-based TS statistic                    %.3f",
      object@twostage$test
    )
  }

  # Replace p-value if available
  if (!is.null(object@twostage$pval)) {
    pval_line_idx <- grep("P-value \\(Chi-square\\)", modified_output)
    if (length(pval_line_idx) > 0) {
      modified_output[pval_line_idx] <- sub(
        "\\d+\\.\\d+",
        sprintf("%.3f", object@twostage$pval),
        modified_output[pval_line_idx]
      )
    }
  }

  # Print the modified output
  cat(paste(modified_output, collapse = "\n"))
  invisible(object)
})


#' Summary method for twostage objects
#'
#' Provides a summary for objects of class "twostage".
#'
#' @param object An object of class "twostage".
#' @param ... Additional arguments (currently not used).
#' @return The summary of the "twostage" object.
#' @exportMethod summary
#'
setMethod(
  "summary", "twostage",
  function(object, ...) {
    if (!inherits(object, "twostage")) {
      stop("This does not appear to be an object generated by twostage()!")
    }

    # create a table of estimates and ses, including naive ses and TSML ses
    TS_table <- parameterEstimates_ts(object, naive.se = TRUE)

    # create a sentence with test statistic results to print
    Tres <- object@twostage$test
    df <- object@twostage$df
    pval <- object@twostage$pval
    colnames(Tres) <- "Tres"
    colnames(pval) <- "pval"
    df <- as.matrix(df)
    colnames(df) <- "df"

    # summary list
    summary_list <- list(
      TS_table = TS_table,
      Tres = Tres,
      pval = pval,
      df = df
    )

    # Assign S3 class for method dispatch
    class(summary_list) <- "SummaryTwostage"

    summary_list
  }
)

#' Print method for SummaryTwostage objects (S3)
#'
#' @param x An object of class 'SummaryTwostage'
#' @param ... Additional arguments (currently not used)
#' @export
print.SummaryTwostage <- function(x, ...) {
  # Create a rounded table of estimates for display
  TS_table_round <- as.data.frame(lapply(x$TS_table, function(column) {
    if (is.numeric(column)) round(column, 3) else column
  }))

  # Test statistic values
  Tres <- x$Tres
  df <- x$df
  pval <- x$pval

  if (!is.null(Tres)) {
    test.output <- paste(
      "The residual-based TSML chi-square is", round(Tres, 3),
      "against", df, "degrees of freedom, with a p-value of",
      round(pval, 3)
    )
  } else {
    test.output <- paste("The residual-based TSML chi-square could not be computed.")
  }

  cat("Summary of Two-Stage Analysis \n")
  cat("----------------------------\n")
  cat(
    "Parameter estimates from Stage 2, naive standard errors from lavaan",
    "(with z-test and p-value),\n", "and the corrected TSML standard errors",
    "(with z-test and p-value): \n"
  )
  print(TS_table_round, quote = FALSE, row.names = FALSE)
  cat("----------------------------\n")
  cat(test.output, "\n")
}



#' Expanded fit measures for twostage objects
#'
#' @inheritParams lavaan::fitMeasures
#' @return Named vector of fit measures including chisq_TS_res and pvalue_TS_res
#' @exportMethod fitMeasures
setMethod(
  "fitMeasures", "twostage",
  function(object, fit.measures = "all",
           baseline.model = NULL, h1.model = NULL,
           fm.args = list(
             standard.test = "default",
             scaled.test = "default",
             rmsea.ci.level = 0.90,
             rmsea.close.h0 = 0.05,
             rmsea.notclose.h0 = 0.08,
             robust = TRUE,
             cat.check.pd = TRUE
           ),
           output = "vector", ...) {
    fitm <- callNextMethod()

    # Add TSML-specific measures, using NA when computation failed
    fitm["chisq_TS_res"] <- if (is.null(object@twostage$test)) NA_real_ else object@twostage$test
    fitm["pvalue_TS_res"] <- if (is.null(object@twostage$pval)) NA_real_ else object@twostage$pval

    return(fitm)
  }
)

#' Parameter Estimates for twostage objects
#'
#' @param object An object of class twostage
#' @param naive.se (logical) Whether to print naive Stage 2 SEs
#' @param ... Other arguments to pass to parameterEstimates of lavaan
#' @returns Object of class twostage_parameterEstimates with TS SEs
#' @export
#'
parameterEstimates_ts <- function(object, naive.se = TRUE, ...) {
  if (!inherits(object, "twostage")) {
    stop("This does not appear to be an object generated by twostage()!")
  }

  # Get estimates from lavaan's function
  # by default, no ses or CIs when class isn't only lavaan
  est <- parameterEstimates(object, se = naive.se, ...)

  # Rename columns to indicate they're naive
  names(est)[names(est) == "se"] <- "se_naive"
  names(est)[names(est) == "z"] <- "z_naive"
  names(est)[names(est) == "pvalue"] <- "pvalue_naive"
  names(est)[names(est) == "ci.lower"] <- "ci.lower_naive"
  names(est)[names(est) == "ci.upper"] <- "ci.upper_naive"

  # Add TSML standard errors if available
  se_ts <- object@twostage$se_ts # [object@ParTable$free != 0]

  if (!is.null(se_ts)) {
    # Filter se_ts to match the rows returned by parameterEstimates
    # Use the row numbers from est to subset the original parameter table
    # Ensures remove.nonfree=TRUE works, etc
    original_rows <- match(
      paste(est$lhs, est$op, est$rhs),
      paste(object@ParTable$lhs, object@ParTable$op, object@ParTable$rhs)
    )

    filtered_se_ts <- se_ts[original_rows]
    est$se_ts <- filtered_se_ts
    est$z_ts <- ifelse(filtered_se_ts != 0 & !is.na(filtered_se_ts), est$est / filtered_se_ts, NA)
    est$pvalue_ts <- ifelse(!is.na(est$z_ts), 2 * (1 - pnorm(abs(est$z_ts))), NA)
  }

  # Set custom class, adding to lavaan.parameterEstimates
  class(est) <- c("twostage_parameterEstimates", class(est))

  return(est)
}


# because I can never remember whether upper or lower case...
#' @rdname parameterEstimates_ts
#' @export
parameterestimates_ts <- parameterEstimates_ts


#--------NOT USED ---------------#


# an idea is to create subclass for PIM for fitMeasures and parameterestimates?
# For now, stick with ordinary function
# # Create subclass
# setClass("lavaan_pim", contains = "lavaan")
#
# # PIM functions return this subclass
# pim_result <- new("lavaan_pim", regular_lavaan_result)
#
# # Custom method
# setMethod("fitMeasures", "lavaan_pim", function(object, ...) {
#   fm <- callNextMethod()  # calls lavaan's method
#   # modify specific values
#   fm
# })
